---
layout: post
title: Punity, a Unity-like game engine for the Raspberry Pi Pico
---

**Greetings!** I am at the beginning of my blogging journey. If you like my writing, please support me by leaving a **star** on [this project](https://github.com/extremq/punity). 
{: .message }


![A picture of my game.](/assets/images/002/punity.png){:.centered}

A picture of my game.
{: .caption}

I had the task of creating a game in C++ for my University's <abbr title="Object Oriented Programming">OOP</abbr> class. 
Students usually build their game on top of the professor's template[^sfml], but I wanted to do something different.

I wanted to create a **game engine**. One that would be easy to use but could be extended to allow for developing more complex games.

In this article I will explain the step-by-step process of my development, all of it cumulating to me winning a **prize from Amazon**[^amazon] and getting **1<sup>st</sup> place at the University's Student Scientific Communications Session**[^scss].

# Unity as a case study
I had some experience with Unity[^unity] and I liked how easy it was to create a game with it.

In Unity, your building blocks are **GameObjects**. You can attach **Components** to them, which in essence are scripts that can be used to add functionality to the GameObject.

I feel like the best way to get a grasp of how Unity works is to show you a simple script:
```csharp
using UnityEngine;

/*
*   Example script that moves the GameObject 
*   forward at a constant speed.
*/

// All scripts must inherit from MonoBehaviour
public class MoveObject : MonoBehaviour
{
    public float speed = 10f; // Speed in units per second

    // Transform is a component that holds the position,
    // rotation and scale of the GameObject
    private Transform objectTransform;

    // Start is called before the first frame update
    private void Start()
    {
        objectTransform = GetComponent<Transform>();
    }

    // Update is called once per frame
    private void Update()
    {
        // Move the GameObject
        objectTransform.Translate(
            Vector3.forward * speed * Time.deltaTime
        );
    }
}
```
This script can be attached to any GameObject and it will move it forward at a constant speed. 

![Unity's Rigidbody component attached to a GameObject.](/assets/images/002/unity-gameobject.png){:.centered}

Unity's Rigidbody component attached to a GameObject.
{: .caption}

Another thing you should know is that GameObjects form a tree structure[^tree]. This means that a GameObject can have children GameObjects.

![Nested GameObjects.](/assets/images/002/unity-nesting.png){:.centered}

Nested GameObjects.
{: .caption}

Basically, Unity lets you treat GameObjects as if they were directories in a file system, while Components are the files. For example, deleting a GameObject will delete all of its children GameObjects and their Components.

I wanted this kind of behavior in my game engine. It felt natural and easy to use. 

So I started working on it.

# The first iteration

A lesson that I learned immediately was that you should **never** start a project by writing code. You should always start by writing down your ideas and planning your project.

I'm telling you this because my first iteration[^first-iteration] had to be scrapped. I didn't plan correctly and ended up creating something that I didn't want to code a game with.

My **biggest mistake** was that I didn't think I need the tree structure Unity had. I thought a list of GameObjects would suffice. But in reality, it was a pain to work with.

Not only that, but I used inheritance instead of composition[^composition] for Components. This meant I had to create a new class for each Component which is not dynamic and scales poorly. :(

However, I made progress:

I wrote a really fast driver for my display. 

![A picture of my display showcasing its power.](/assets/images/002/display.gif){:.centered}

A picture of my display showcasing its power.
{: .caption}

I achieved this speed by coming up with something similar to a **double buffer**[^double-buffer]. I had two buffers, one that represented the last frame and one that represented the new frame. I then calculated the difference between the two and only updated the pixels that changed! 

![The change matrix. Elements which are 1 are different, while elements which are 0 are the same.](/assets/images/002/change-matrix.png){:.centered}

The change matrix. Elements which are 1 are different, while elements which are 0 are the same.
{: .caption}

This simple optimization made my game run at 60 frames per second with no flickering.

I also wrote a driver for the joystick!

![A picture of my joystick driver. The potentiometer had a problem.](/assets/images/002/joystick.gif){:.centered}

A picture of my joystick driver. The potentiometer had a problem.
{: .caption}

I put an end to this first game engine iteration right after I also implemented collision. I wanted to make a simple map and... I was beginning to feel how inconvenient it was to work with the inheritance-based Components.

![Collision working.](/assets/images/002/collision.gif){:.centered}

Collision working.
{: .caption}

I *had* to start over.

# A new beginning

[^amazon]: In Romania, Amazon hosts student contests called "Amazon Learn & Earn". They each have prizes of a few hundred euros. It's a fun thing to participate in and they usually take a whole semester.
[^scss]: My university hosts a Student Scientific Communications Sessions each year. It's a contest where (usually final year) students present publications and the best ones get prizes. 
[^sfml]: The template uses [SFML](https://www.sfml-dev.org/) is a C++ library for multimedia programming. It's used to create games and other multimedia applications.
[^unity]: [Unity](https://unity.com/) is a game engine that allows you to create games for multiple platforms and is the leading game engine in the industry.
[^tree]: A [tree structure](https://en.wikipedia.org/wiki/Tree_(data_structure)) is a way of organizing data in a hierarchical manner. It's called a tree because it looks like a tree, with a root and branches.
[^first-iteration]: [My first iteration](https://github.com/extremq/pico_game/) had major issues, but you can still check it out if you want.
[^composition]: [Composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance) is a programming principle that states that you should prefer composition over inheritance. Inheritance is when you create a new class that inherits from another class. Composition is when you create a new class that contains an instance of another class.
[^double-buffer]: A [double buffer](https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics) is a technique used to reduce flickering in computer graphics. It works by having two buffers, one that is displayed and one that is being drawn to. When the drawing is done, the buffers are swapped.